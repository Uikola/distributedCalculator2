// Code generated by MockGen. DO NOT EDIT.
// Source: handler.go
//
// Generated by this command:
//
//	mockgen -source=handler.go -destination=mocks/mock_expressionUsecase.go -package=mocks expressionUseCase
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	entity "github.com/Uikola/distributedCalculator2/orchestrator/internal/entity"
	gomock "go.uber.org/mock/gomock"
)

// MockexpressionUseCase is a mock of expressionUseCase interface.
type MockexpressionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockexpressionUseCaseMockRecorder
}

// MockexpressionUseCaseMockRecorder is the mock recorder for MockexpressionUseCase.
type MockexpressionUseCaseMockRecorder struct {
	mock *MockexpressionUseCase
}

// NewMockexpressionUseCase creates a new mock instance.
func NewMockexpressionUseCase(ctrl *gomock.Controller) *MockexpressionUseCase {
	mock := &MockexpressionUseCase{ctrl: ctrl}
	mock.recorder = &MockexpressionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockexpressionUseCase) EXPECT() *MockexpressionUseCaseMockRecorder {
	return m.recorder
}

// AddExpression mocks base method.
func (m *MockexpressionUseCase) AddExpression(ctx context.Context, expression string, userID uint) (uint, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddExpression", ctx, expression, userID)
	ret0, _ := ret[0].(uint)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AddExpression indicates an expected call of AddExpression.
func (mr *MockexpressionUseCaseMockRecorder) AddExpression(ctx, expression, userID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddExpression", reflect.TypeOf((*MockexpressionUseCase)(nil).AddExpression), ctx, expression, userID)
}

// GetExpression mocks base method.
func (m *MockexpressionUseCase) GetExpression(ctx context.Context, userID, expressionID uint) (entity.Expression, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetExpression", ctx, userID, expressionID)
	ret0, _ := ret[0].(entity.Expression)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetExpression indicates an expected call of GetExpression.
func (mr *MockexpressionUseCaseMockRecorder) GetExpression(ctx, userID, expressionID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetExpression", reflect.TypeOf((*MockexpressionUseCase)(nil).GetExpression), ctx, userID, expressionID)
}

// GetResult mocks base method.
func (m *MockexpressionUseCase) GetResult(ctx context.Context, expressionID uint) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetResult", ctx, expressionID)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetResult indicates an expected call of GetResult.
func (mr *MockexpressionUseCaseMockRecorder) GetResult(ctx, expressionID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetResult", reflect.TypeOf((*MockexpressionUseCase)(nil).GetResult), ctx, expressionID)
}

// ListExpressions mocks base method.
func (m *MockexpressionUseCase) ListExpressions(ctx context.Context) ([]entity.Expression, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListExpressions", ctx)
	ret0, _ := ret[0].([]entity.Expression)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListExpressions indicates an expected call of ListExpressions.
func (mr *MockexpressionUseCaseMockRecorder) ListExpressions(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListExpressions", reflect.TypeOf((*MockexpressionUseCase)(nil).ListExpressions), ctx)
}
